Metadata-Version: 2.4
Name: informal-bids
Version: 0.3.0
Summary: MCMC estimation for informal bid admission cutoffs in auctions
Requires-Python: >=3.9
Description-Content-Type: text/markdown
Requires-Dist: numpy
Requires-Dist: scipy
Requires-Dist: matplotlib
Requires-Dist: seaborn
Requires-Dist: pandas
Requires-Dist: numba

# Informal Bids (clean-slate refactor)

Selection-aware Bayesian estimation for two-stage (informal â†’ formal) M&A auctions.

This branch (`extend(270126)`) intentionally **restarts the codebase from a clean slate** for a new meeting. The previous implementation is preserved in git history (and on branch `two_stage`).

## Model (Task B)

Per auction `i` with bidders `j=1..J`:

- Valuations: `v_ij = gamma + nu_ij`, `nu_ij ~ N(0, sigma_nu^2)`
- Informal bids (misreporting): `bI_ij = lambda_I(J,kappa) * v_ij`
- Cutoff (bid units): `b*_i = X_i' beta + omega_i`, `omega_i ~ N(0, sigma_omega^2)`
- Admission: bidder admitted iff `bI_ij >= b*_i` (Candidate 3 uses a type shift)
- Selection: only auctions with at least one admitted bidder are observed
- Due diligence: `u_ij = v_ij + eta_ij`, `eta_ij ~ N(0, sigma_eta^2)`
- Formal bids (admitted only): `bF_ij = (1 - 1/J) * u_ij`

Inference uses Metropolis-within-Gibbs with RW-MH for global parameters.

## Cutoff/admission specifications

Specs are registered in `src/informal_bids/specs.py`:

- Legacy baselines:
  - `legacy_intercept`
  - `legacy_moments_k4`
  - `legacy_depth_k2`
  - `legacy_depth_k2_ratio`
- New candidates:
  - `cand1_type_spr`
  - `cand2_type_spr_depth_z`
  - `cand3_type_shift_admission`
  - `cand4_type_spr_prec_z`

## Install

```bash
python -m venv .venv
source .venv/bin/activate
pip install -e .
```

## Run

Single run (sim + fit):

```bash
task-b-run --spec cand1_type_spr --N 100 --seed 123 --out outputs/run_v1
```

Comparison suite (writes `compare.csv`):

```bash
task-b-compare --out outputs/compare_v1 --N 20,50,100,200 --rep 3 --seed 123
```

Outputs are written under `outputs/` (keep untracked).

### Performance / quick presets

For faster iteration, reduce MCMC work:

```bash
task-b-compare --out outputs/compare_fast --N 20,50,100 --rep 1 --iters 4000 --burn 2000 --chains 1
```
